{"id":"node_modules/rxjs/operators/throttleTime.js","dependencies":[{"name":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\operators\\throttleTime.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\pooya\\Desktop\\poomap\\package.json","includedInParent":true,"mtime":1594932269761},{"name":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1594932268869},{"name":"../Subscriber","loc":{"line":7,"column":27},"parent":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\operators\\throttleTime.js","resolved":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\Subscriber.js"},{"name":"../scheduler/async","loc":{"line":8,"column":22},"parent":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\operators\\throttleTime.js","resolved":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\scheduler\\async.js"},{"name":"./throttle","loc":{"line":9,"column":25},"parent":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\operators\\throttleTime.js","resolved":"C:\\Users\\pooya\\Desktop\\poomap\\node_modules\\rxjs\\operators\\throttle.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nvar throttle_1 = require('./throttle');\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n"},"sourceMaps":{"js":{"version":3,"file":"throttleTime.js","sourceRoot":"","sources":["../../src/operators/throttleTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: IScheduler = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n"]}},"error":null,"hash":"d1e8639ec25119fea09b398ed7b1e3f1","cacheData":{"env":{}}}